---
layout: post
title: 模糊测试
date: 2022-09-21
tags: 自动化测试
---

模糊测试

## 起源与发展

模糊测试起源于Barton P. Miller的一次经验：在一次雷雨交加的通话中，雷电导致了一些通信的字符变成了乱码，而这些乱码竟导致了程序的崩溃。于是他就提出了模糊测试。他的技术构想是：

- 核心组件：一组用于产生随机字符的程序
- 中心思想：以随机字符串作为输入，运行操作系统组件，观察是否崩溃
- 最终结果：保留能够产生崩溃的字符串输入，分析崩溃类型，对崩溃进行分类

## 概念与框架

模糊测试最初的构想中包含三个要素：一个（套）工具——模糊器、一个目标——待测程序、一个循环——执行程序--崩溃分派。

![](https://newtank1.github.io/assets/images/QQ截图20220923101426.png)

## 家族与分类

模糊测试框架有很多分类方式。

根据基础Fuzzer划分家族有AFL家族（C、C++）、LibFuzzer家族（C、C++）、JQF家族（Java）、其他（Rust、Python等）。

根据组件核心或技术贡献进行分类：

- 按照采用的运行时信息：黑盒、白盒、灰盒
- 按照输入生成的策略：基于变异、基于生成
- 按照引导过程：启发式算法、梯度下降
- 按照测试目的：定向、非定向、某一类缺陷
- 按照应用领域：网络协议、编译器、DNN、IoT、内核
- 按照优化角度：种子调度、变异策略、能量调度、过程建模

### 按照运行时信息分类

#### 黑盒测试

- 特点：只从输入输出端入手优化模糊测试。
- 引导方式：利用输入格式和输出状态引导测试执行。
- 优缺点：效率高，但引导的有效性欠缺。
- 代表性工作：KIF、IoTFuzzer、CodeAlchemist

#### 白盒测试

- 特点：使用混合执行、污点分析等静态分析技术
- 引导方式：利用程序分析结果引导测试执行
- 优缺点：反馈更加有效，但效率不高、适配性较差
- 代表性工作：Driller、QSYM、CONFETTI

#### 灰盒测试

Coverage-based Greybox Fuzzing, CGF

- 采用轻量级插桩进行监控，收集分支覆盖、线程执行、堆栈状态等信息
- 引导方式：利用收集到的内部状态引导测试执行
- 代表性工作：AFL、AFLGo、EcoFuzz、Zest、BeDivFuzz

![](https://newtank1.github.io/assets/images/QQ截图20220923103916.png)

### 按照生成策略分类

#### Mutation-based

基于随机变异或启发式变异策略

- 本质：将种子输入转换为比特串，对比特串进行变化
- 优点：可拓展性强，易于泛化，理论上可用于各类输入
- 缺点：容易产生无效输入